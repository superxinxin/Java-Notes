# 牛客网秋招真题
## 合唱团
### 题目描述
&emsp;&emsp;牛牛的作业薄上有一个长度为 n 的排列 A，这个排列包含了从1到n的n个数，但是因为一些原因，其中有一些位置（不超过 10 个）看不清了，但是牛牛记得这个数列顺序对的数量是 k，顺序对是指满足 i < j 且 A[i] < A[j] 的对数，请帮助牛牛计算出，符合这个要求的合法排列的数目。
### 输入描述:
&emsp;&emsp;每个输入包含一个测试用例。每个测试用例的第一行包含两个整数 n 和 k（1 <= n <= 100, 0 <= k <= 1000000000），接下来的 1 行，包含 n 个数字表示排列 A，其中等于0的项表示看不清的位置（不超过 10 个）。
### 输出描述:
输出一行表示合法的排列数目。

### 示例1
```
输入
5 5
4 0 0 2 0

输出
2
```
### 答案代码
```java
import java.util.Scanner;
//合唱团 
public class Main
{
	public static void main(String[] args)
	{
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] arr = new int[n+1];
		for(int i=1; i<=n; i++)
		{
			arr[i] = in.nextInt();
		}
		int kk = in.nextInt();
		int dd = in.nextInt();
		long[][] f = new long[n+1][kk+1];
		long[][] g = new long[n+1][kk+1];
		for(int one=1; one<=n; one++)
		{
			f[one][1] = arr[one];
			g[one][1] = arr[one];
		}
		for(int k=2; k<=kk; k++)
		{
			for(int one=k; one<=n; one++)
			{
				long tempmax = Integer.MIN_VALUE;
				long tempmin = Integer.MAX_VALUE;
				for(int left=Math.max(one-dd, k-1); left<=one-1; left++)
				{
					if(tempmax < Math.max(f[left][k-1]*arr[one],g[left][k-1]*arr[one]))
					{
						tempmax = Math.max(f[left][k-1]*arr[one],g[left][k-1]*arr[one]);
					}
					if(tempmin > Math.min(f[left][k-1]*arr[one],g[left][k-1]*arr[one]))
					{
						tempmin = Math.min(f[left][k-1]*arr[one],g[left][k-1]*arr[one]);
					}
				}
				f[one][k] = tempmax;
				g[one][k] = tempmin;
			}
		}
		long result = Long.MIN_VALUE;
		for(int i=kk; i<=n; i++)
		{
			if(result < f[i][kk])
			{
				result = f[i][kk];
			}
		}
		System.out.println(result);
	}
}
```
### 答案解析
待更
